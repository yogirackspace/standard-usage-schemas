<schema
    elementFormDefault="qualified"
    attributeFormDefault="unqualified"
    xmlns="http://www.w3.org/2001/XMLSchema"
    xmlns:schema="http://docs.rackspace.com/core/usage/schema"
    xmlns:usage="http://docs.rackspace.com/core/usage"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:xerces="http://xerces.apache.org"
    xmlns:saxon="http://saxon.sf.net/"
    xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning"
    targetNamespace="http://docs.rackspace.com/core/usage/schema"
    version="1.0">

    <import namespace="http://docs.rackspace.com/core/usage"
            schemaLocation="../../core_xsd/ProductExtension-Annotations.xsd"/>

    <element name="alternatives" type="schema:ProductSimpleSchemaAlternatives"/>

    <element name="productSchema" type="schema:ProductSimpleSchemaBase">
        <alternative test="contains(@type,'USAGE') or not(@type)" type="schema:ProductSimpleUsageSchema"/>
        <alternative test="not(contains(@type,'USAGE'))" type="schema:ProductSimpleSchema"/>
    </element>

    <!--
        Complex Types
    -->
    <complexType name="ProductSimpleSchemaAlternatives">
        <annotation>
            <documentation>
                <html:p>
                    A list of alternative versions of a simple product schemas.
                </html:p>
            </documentation>
        </annotation>
        <sequence>
            <element ref="schema:productSchema" minOccurs="1" maxOccurs="unbounded"/>
        </sequence>
        <assert vc:minVersion="1.1"
                test="every $pd in schema:productSchema satisfies $pd/@serviceCode = schema:productSchema[1]/@serviceCode"
                xerces:message="All alternative schemas should share the same service code."
                saxon:message="All alternative schemas should share the same service code.">
            <annotation>
                <documentation>
                    <html:p>
                        All alternative schemas should share the same service code.
                    </html:p>
                </documentation>
            </annotation>
        </assert>
        <assert vc:minVersion="1.1"
                test="every $pd in schema:productSchema satisfies $pd/@namespace = schema:productSchema[1]/@namespace"
                xerces:message="All alternative schemas should share the same namespace."
                saxon:message="All alternative schemas should share the same namespace.">
            <annotation>
                <documentation>
                    <html:p>
                        All alternative schemas should share the same namespace.
                    </html:p>
                </documentation>
            </annotation>
        </assert>
        <assert vc:minVersion="1.1"
                test="count(distinct-values(schema:productSchema/@version)) = count(schema:productSchema)"
                xerces:message="Alternate message versions should each have a unique version identifier."
                saxon:message="Alternate message versions should each have a unique version identifier.">
            <annotation>
                <documentation>
                    <html:p>
                        Alternate message versions should each have a unique version identifier.
                    </html:p>
                </documentation>
            </annotation>
        </assert>
    </complexType>

    <complexType name="ProductSimpleSchemaBase">
        <all>
            <element name="description" type="xsd:string">
                <annotation>
                    <documentation>
                        <html:p>
                            A description for the schema.
                        </html:p>
                    </documentation>
                </annotation>
            </element>
        </all>
        <attribute name="version" type="xsd:string" use="required">
                <annotation>
                    <documentation>
                        <html:p>
                            The version of this particular product
                            schema.  Any sort of version string is
                            allowed. Each product schema must have a
                            unique version.
                        </html:p>
                    </documentation>
                </annotation>
        </attribute>
        <attribute name="type" type="usage:TypeList" use="optional" default="USAGE">
            <annotation>
                <documentation>
                    <html:p>
                        The types of messages that are applicable to
                        this schema.
                    </html:p>
                </documentation>
            </annotation>
        </attribute>
        <attribute name="namespace" type="xsd:anyURI" use="required">
            <annotation>
                <documentation>
                    <html:p>
                        The namespace for the schema.  The namespace
                        must be unique for each product.  The same
                        namespace may be used between product schema
                        versions.
                    </html:p>
                </documentation>
            </annotation>
        </attribute>
        <attribute name="resourceTypes" type="schema:NameList" use="optional">
            <annotation>
                <documentation>
                    <html:p>
                        A whitespace separated list of resource types.
                        A product schema
                        <html:strong>must</html:strong> specify at
                        least one resource type if the groupByResource
                        attribute is true.
                    </html:p>
                </documentation>
            </annotation>
        </attribute>
        <attribute name="serviceCode" type="xsd:Name" use="required">
            <annotation>
                <documentation>
                    <html:p>
                        The name of the product or service. Should be
                        a single word, no white-spaces are
                        allowed. Example names "nova", "MaaS",
                        etc. The name should uniquely identify the
                        product or service.  The name is used to
                        construct atom categories for events of this
                        type.
                    </html:p>
                </documentation>
            </annotation>
        </attribute>
    </complexType>

    <complexType name="ProductSimpleSchema">
        <complexContent>
            <extension base="schema:ProductSimpleSchemaBase">
                <all>
                    <element name="attribute" type="schema:Attribute" minOccurs="0" maxOccurs="50">
                        <annotation>
                            <documentation>
                                <html:p>
                                    A set of custom attributes. Currently,
                                    only 50 custom attributes are allowed for
                                    a product schema.
                                </html:p>
                            </documentation>
                        </annotation>
                    </element>
                    <element name="attributeGroup" type="schema:AttributeGroup" minOccurs="0" maxOccurs="20">
                        <annotation>
                            <documentation>
                                <html:p>
                                    A set of custom attributes groups.
                                    Currently only 20 groups are
                                    allowed for a product schema.
                                </html:p>
                            </documentation>
                        </annotation>
                    </element>
                    <element name="xpathAssertion" type="schema:XPathAssertion" minOccurs="0" maxOccurs="unbounded">
                        <annotation>
                            <documentation>
                                <html:p>
                                    A set of xpath assertions.
                                </html:p>
                            </documentation>
                        </annotation>
                    </element>
                </all>
            </extension>
        </complexContent>
    </complexType>

    <complexType name="AttributeGroup">
        <sequence>
            <element name="description" type="xsd:string">
                <annotation>
                    <documentation>
                        <html:p>
                            A description of the attribute group.
                        </html:p>
                    </documentation>
                </annotation>
            </element>
            <element name="attribute" type="schema:Attribute" minOccurs="0" maxOccurs="50">
                <annotation>
                    <documentation>
                        <html:p>
                            A set of custom attributes. Currently,
                            only 50 custom attributes are allowed for
                            a product schema.
                        </html:p>
                    </documentation>
                </annotation>
            </element>
        </sequence>
        <attribute name="name" type="xsd:Name" use="required">
            <annotation>
                <documentation>
                    <html:p>
                        The name of the attribute group.
                    </html:p>
                </documentation>
            </annotation>
        </attribute>
        <attribute name="minOccurs" type="schema:MinOccurs" use="optional" default="1">
            <annotation>
                <documentation>
                    <html:p>
                        Minimum occurrence of the attribute group.
                    </html:p>
                </documentation>
            </annotation>
        </attribute>
        <attribute name="maxOccurs" type="schema:MaxOccurs" use="optional" default="1">
            <annotation>
                <documentation>
                    <html:p>
                        Maximum occurrence of the attribute group.
                    </html:p>
                </documentation>
            </annotation>
        </attribute>
    </complexType>

    <complexType name="ProductSimpleUsageSchema">
        <complexContent>
            <extension base="schema:ProductSimpleSchemaBase">
                <all>
                    <element name="aggregationPeriods" type="schema:AggregationPeriods" minOccurs="0">
                        <annotation>
                            <documentation>
                                <html:p>
                                    An optional list of periods specifying aggregation
                                    periods. Usage events will be aggregated together when
                                    their startTime or eventTime (whichever is present)
                                    falls into the same aggregation period. Note we use
                                    the word Period to match the JodaTime sense of the
                                    word, which is distinguished from a Duration in that
                                    it takes into consideration leap years / seconds, etc.
                                </html:p>
                                <html:p>
                                    The first aggregation period begins at midnight, UTC.
                                    The time period of the first period is the first element
                                    in this list. Each subsequent element in this list
                                    defines the time period of subsequent aggregation periods,
                                    in order.
                                </html:p>
                                <html:p>
                                    The period is inclusive of the start time, and
                                    exclusive of the end time (calculated as start time +
                                    time period, taking into account leap years / leap seconds,
                                    etc.)). Each subsequent aggregation period begins at
                                    the end time of the previous aggregation period.
                                </html:p>
                                <html:p>
                                    The time periods in this list must sum to 24 hours exactly.
                                    When not specified, a single aggregation period with a
                                    duration of 24 hours is used. This default value of 24
                                    hours should apply in most cases. However, during the
                                    "soak period" used for product on-boarding, it may be
                                    important to aggregate multiple times per day.
                                </html:p>
                            </documentation>
                        </annotation>
                    </element>
                    <element name="attribute" type="schema:UsageAttribute" minOccurs="0" maxOccurs="50">
                        <annotation>
                            <documentation>
                                <html:p>
                                    A set of custom usage
                                    attributes. Currently, only 50
                                    custom attributes are allowed for
                                    a product schema.
                                </html:p>
                            </documentation>
                        </annotation>
                    </element>
                    <element name="xpathAssertion" type="schema:XPathAssertion" minOccurs="0" maxOccurs="unbounded">
                        <annotation>
                            <documentation>
                                <html:p>
                                    A set of xpath assertions.
                                </html:p>
                            </documentation>
                        </annotation>
                    </element>
                </all>
                <attribute name="groupByResource" type="xsd:boolean"
                           use="optional" default="true">
                    <annotation>
                        <documentation>
                            <html:p>
                                If groupByResource is true then attributes are
                                grouped by the resourceID.  In other words,
                                the product is being charged per resource.  If
                                not, that attributes are grouped at the
                                tenant level.  The default is true which
                                should apply to most products.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <assert vc:minVersion="1.1"
                        test="every $frequencyAttribute in schema:attribute/@frequencyAttribute satisfies schema:attribute[@name = $frequencyAttribute]"
                        xerces:message="If frequencyAttribute is set then it must match the name of an attribute defined in this schema."
                        saxon:message="If frequencyAttribute is set then it must match the name of an attribute defined in this schema.">
                    <annotation>
                        <documentation>
                            <html:p>
                                If frequencyAttribute is set then it must
                                point to an attribute defined in this schema.
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
                <assert vc:minVersion="1.1"
                        test="every $frequencyAttribute in schema:attribute/@frequencyAttribute satisfies
                              schema:attribute[@name = $frequencyAttribute]/@type =
                              ('integer', 'long', 'int', 'short',
                              'byte', 'unsignedLong', 'unsignedInt',
                              'unsignedShort', 'unsignedByte', 'double',
                              'float')"
                        xerces:message="If frequencyAttribute is set then it must point to an attribute of a numeric type."
                        saxon:message="If frequencyAttribute is set then it must point to an attribute of a numeric type."
                        >
                    <annotation>
                        <documentation>
                            <html:p>
                                The frequencyAttribute should point to an
                                attribute whose type is numeric.
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
                <assert vc:minVersion="1.1"
                        test="if ((@groupByResource = true()) and (not(@resourceTypes))) then false() else true()"
                        xerces:message="If groupByResource=true (or not specified), then the resourceTypes attribute must be supplied."
                        saxon:message="If groupByResource=true (or not specified), then the resourceType attribute must be supplied.">
                    <annotation>
                        <documentation>
                            <html:p>
                                If groupByResource is true then the
                                resourceTypes attribute must be specified.
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
                <assert vc:minVersion="1.1"
                        test="if (schema:attribute[string(@frequency) = 'DURATION']) then string(@type)='USAGE' else true()"
                        xerces:message="If there is an attribute with a frequency of DURATION, then the message type should be USAGE"
                        saxon:message="If there is an attribute with a frequency of DURATION, then the message type should be USAGE">
                    <annotation>
                        <documentation>
                            <html:p>
                                Only USAGE messages should have a
                                frequency of DURATION.
                                (USAGE_SNAPSHOT messages shouldn't).
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
            </extension>
        </complexContent>
    </complexType>

    <complexType name="AggregationPeriods">
        <sequence>
            <element name="aggregationPeriod" type="xsd:dayTimeDuration" maxOccurs="unbounded">
                <annotation>
                    <documentation>
                        <html:p>
                            A duration of one of the aggregation periods.
                        </html:p>
                    </documentation>
                </annotation>
            </element>
        </sequence>
        <assert vc:minVersion="1.1"
            test="xsd:dayTimeDuration('PT24H') = sum(for $d in element(schema:aggregationPeriod) return xsd:dayTimeDuration(string($d)))"
            xerces:message="The list of time periods specified in aggregationPeriods must sum to exactly 24 hours."
            saxon:message="The list of time periods specified in aggregationPeriods must sum to exactly 24 hours.">
            <annotation>
                <documentation>
                    <html:p>
                        The list of time periods specified in
                        aggregationPeriods must sum to
                        exactly 24 hours.
                    </html:p>
                </documentation>
            </annotation>
        </assert>
    </complexType>

    <complexType name="UsageAttribute">
        <simpleContent>
            <extension base="schema:Attribute">
                <attribute name="aggregateFunction" type="usage:AggregateFunction" use="optional" default="NONE">
                    <annotation>
                        <documentation>
                            <html:p>
                                For usage.  A description of how
                                values for this attribute should be
                                aggregated.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="unitOfMeasure" type="usage:UnitOfMeasure" use="optional">
                    <annotation>
                        <documentation>
                            <html:p>
                                The unit of measure for the attribute.
                                Note that if an aggregate function is
                                specified, then a unit of measure
                                should also be specified.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="groupBy" type="xsd:boolean" use="optional" default="false">
                    <annotation>
                        <documentation>
                            <html:p>
                                All attributes with a groupBy value of
                                true will be grouped for the purpose
                                of aggregation.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="billable" type="xsd:boolean" use="optional" default="true">
                    <annotation>
                        <documentation>
                            <html:p>
                                This is an attribute that is used for
                                billing purposes.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="frequency" type="usage:Frequency" use="optional">
                    <annotation>
                        <documentation>
                            <html:p>
                                If the aggregateFunction is
                                CUMULATIVE_AVG, then this frequency
                                value is used to compute the
                                cumulative avg.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="frequencyAttribute" type="xsd:string" use="optional">
                    <annotation>
                        <documentation>
                            <html:p>
                                If the aggregateFunction is
                                CUMULATIVE_AVG, then
                                frequencyAttribute points to the
                                attribute that contains the frequency
                                value.  The attribute should be an
                                attribute of type integer, long,
                                int, short, byte, unsignedLong,
                                unsignedInt, unsignedShort,
                                unsignedByte, double or float.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <assert vc:minVersion="1.1" test="if (@aggregateFunction!='NONE') then @unitOfMeasure else true()"
                        xerces:message="If a aggregateFunction is supplied then there should also be a unitOfMeasure."
                        saxon:message="If a aggregateFunction is supplied then there should also be a unitOfMeasure.">
                    <annotation>
                        <documentation>
                            <html:p>
                                If an aggregate-function is supplied then so
                                should the unit of measure.
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
                <assert vc:minVersion="1.1" test="if (@aggregateFunction = 'CUMULATIVE_AVG') then @frequency or @frequencyAttribute else true()"
                        xerces:message="If a aggregateFunction is 'CUMULATIVE_AVG' then frequency or frequencyAttribute should be set."
                        saxon:message="If a aggregateFunction is 'CUMULATIVE_AVG' then frequency or frequencyAttribute should be set.">
                    <annotation>
                        <documentation>
                            <html:p>
                                If an aggregateFunction is set to
                                'CUMULATIVE_AVG' then frequency or
                                frequencyAttribute should be set.
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
                <assert vc:minVersion="1.1" test="if (@frequency) then (@aggregateFunction='CUMULATIVE_AVG') and not(@frequencyAttribute) else true()"
                        xerces:message="If the frequency attribute is set then the aggregateFunction should be 'CUMLATIVE_AVG' and frequencyAttribute should not be set."
                        saxon:message="If the frequency attribute is set then the aggregateFunction should be 'CUMLATIVE_AVG' and frequencyAttribute should not be set.">
                    <annotation>
                        <documentation>
                            <html:p>
                                Frequency requires CUMULATIVE_AVG and no
                                frequencyAttribute.
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
                <assert vc:minVersion="1.1" test="if (@frequencyAttribute) then (@aggregateFunction='CUMULATIVE_AVG') and not(@frequency) else true()"
                        xerces:message="If the frequencyAttribute attribute is set then the aggregateFunction should be 'CUMLATIVE_AVG' and frequency should not be set."
                        saxon:message="If the frequencyAttribute attribute is set then the aggregateFunction should be 'CUMLATIVE_AVG' and frequency should not be set.">
                    <annotation>
                        <documentation>
                            <html:p>
                                FrequencyAttribute requires CUMULATIVE_AVG and
                                no frequency.
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
            </extension>
        </simpleContent>
    </complexType>

    <complexType name="Attribute">
        <simpleContent>
            <extension base="xsd:string">
                <attribute name="name" type="xsd:Name" use="required">
                    <annotation>
                        <documentation>
                            <html:p>
                                The name of the attribute. The name
                                must be a single word.  It cannot
                                contain namespaces, it must not start
                                with a number.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="type" type="schema:TypeList" use="required">
                    <annotation>
                        <documentation>
                            <html:p>
                                The types applicable to this attribute.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="use"  type="schema:Use" use="optional" default="optional">
                    <annotation>
                        <documentation>
                            <html:p>
                                Is the attribute optional or
                                required. The use attribute is
                                optional, if not specified the
                                attribute will be labeled as optional.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="fixed" type="xsd:string" use="optional">
                    <annotation>
                        <documentation>
                            <html:p>
                                If the attribute always has a fixed
                                value, the value should be specified
                                here.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="min" type="schema:MinMaxType" use="optional">
                    <annotation>
                        <documentation>
                            <html:p>
                                The minimum value allowed in the
                                numeric type.  The value is inclusive.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="max" type="schema:MinMaxType" use="optional">
                    <annotation>
                        <documentation>
                            <html:p>
                                The minimum value allowed in the
                                numeric type.  The value is inclusive.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="default" type="xsd:string" use="optional">
                    <annotation>
                        <documentation>
                            <html:p>
                                If the attribute has a default value,
                                then the default value should be
                                specified here.  Note that only
                                optional attributes can have default
                                values.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="displayName" type="xsd:string" use="optional">
                    <annotation>
                        <documentation>
                            <html:p>
                                A human readable name for the
                                attribute that can be used for
                                reports, invoices, etc.  The display
                                name does not have the same constraints
                                as the name attribute..it can contain
                                spaces.  "displayName" is an optional
                                attribute. If it is not specified the
                                "name" attribute will be used in
                                reports, invoices, etc.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="allowedValues" type="schema:NameList" use="optional">
                    <annotation>
                        <documentation>
                            <html:p>
                                An optional whitespace separated list
                                of allowed values.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="searchable" type="xsd:boolean" use="optional" default="false">
                    <annotation>
                        <documentation>
                            <html:p>
                                If this is set to true then there
                                should be an index set so that you can
                                search by this attribute.
                            </html:p>
                            <html:p>
                                From a practical perspective this
                                means that an atom hopper category
                                will be set automatically with this
                                attribute value.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="public" type="xsd:boolean" use="optional" default="false">
                    <annotation>
                        <documentation>
                            <html:p>
                                If this is set to true then the
                                attribute value is allowed to be displayed
                                to the public.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <attribute name="maxLength" type="xsd:integer" use="optional">
                    <annotation>
                        <documentation>
                            <html:p>
                                Denotes a maximum length of a string. It can be used only
                                for string types. 
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <assert vc:minVersion="1.1" test="if (@default and @use) then @use='optional' else true()"
                        xerces:message="The attribute has a default value so 'use' must be 'optional'"
                        saxon:message="The attribute has a default value so 'use' must be 'optional'">
                    <annotation>
                        <documentation>
                            <html:p>
                                If the property has a default value then use must be optional.
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
                <assert vc:minVersion="1.1" test="normalize-space(string(.)) != '' and normalize-space(string(.)) != ' '"
                        xerces:message="Each attribute must contain a human readable description within the &lt;attribute/&gt; element."
                        saxon:message="Each attribute must contain a human readable description within the &lt;attribute/&gt; element.">
                    <annotation>
                        <documentation>
                            <html:p>
                                Documentation must not be empty for an attribute.
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
                <assert vc:minVersion="1.1" test="if (@min) then @type=('integer','long','int', 'short', 'byte',
                                                  'unsignedLong','unsignedInt','unsignedShort','unsignedByte','double',
                                                  'float') else true()"
                        xerces:message="You can only set minimum value in numeric types."
                        saxon:message="You can only set minimum value in numeric types.">
                    <annotation>
                        <documentation>
                            <html:p>
                                The minimum value is only allowed with numeric types.
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
                <assert vc:minVersion="1.1" test="if (@max) then @type=('integer','long','int', 'short', 'byte',
                                                  'unsignedLong','unsignedInt','unsignedShort','unsignedByte','double',
                                                  'float') else true()"
                        xerces:message="You can only set maximum value in numeric types."
                        saxon:message="You can only set maximum value in numeric types.">
                    <annotation>
                        <documentation>
                            <html:p>
                                The maximum value is only allowed with numeric types.
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
                <assert vc:minVersion="1.1" test="if (@max or @min) then count(tokenize(string(@type),' ')) = 1 else true()"
                        xerces:message="Using multiple types on an attribute is not allowed when min or max is set."
                        saxon:message="Using multiple types on an attribute is not allowed when min or max is set.">
                    <annotation>
                        <documentation>
                            <html:p>
                                Min and max can't be set on an
                                attribute that is the union of
                                multiple types.
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
                <assert vc:minVersion="1.1" test="if (@maxLength) then @type=('string', 'string*') else true()"
                        xerces:message="You can only set maxLength in string types."
                        saxon:message="You can only set maxLength value in string types.">
                    <annotation>
                        <documentation>
                            <html:p>
                                The maxLength is only allowed with string types.
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
            </extension>
        </simpleContent>
    </complexType>

    <complexType name="XPathAssertion">
        <simpleContent>
            <extension base="xsd:string">
                <attribute name="test" type="xsd:string" use="required">
                    <annotation>
                        <documentation>
                            <html:p>
                                An XPath test, should evaluate to
                                true() or false(). If false(), then
                                the content of the element is returned
                                in an error message.
                            </html:p>
                            <html:p>
                                The context is always the root product
                                element. The prefix 'p' is
                                <html:strong>always</html:strong>
                                bound to the product
                                schema. Currently, there is no way to
                                bound other namespaces, though
                                strictly speaking, since these are
                                product assertions, this shouldn't be
                                necessary.
                            </html:p>
                        </documentation>
                    </annotation>
                </attribute>
                <assert vc:minVersion="1.1" test="normalize-space(string(.)) != '' and normalize-space(string(.)) != ' '"
                        xerces:message="Each xpathAssertion must contain a human readable error message within the &lt;xpathAssertion/&gt; element."
                        saxon:message="Each xpathAssertion must contain a human readable error message within the &lt;xpathAssertion/&gt; element.">
                    <annotation>
                        <documentation>
                            <html:p>
                                Error message must not be empty for the xpathAssertion.
                            </html:p>
                        </documentation>
                    </annotation>
                </assert>
            </extension>
        </simpleContent>
    </complexType>

    <!--
        Simple Types
    -->
    <simpleType name="NameList">
        <list itemType="xsd:Name"/>
    </simpleType>

    <simpleType name="MaxOccurs">
        <union memberTypes="schema:MinOccurs">
            <simpleType>
                <restriction base="xsd:string">
                    <enumeration value="unbounded"/>
                </restriction>
            </simpleType>
        </union>
    </simpleType>

    <simpleType name="MinOccurs">
        <restriction base="xsd:unsignedInt">
            <maxInclusive value="5000"/>
        </restriction>
    </simpleType>

    <simpleType name="MinMaxType">
        <union memberTypes="xsd:double xsd:decimal"/>
    </simpleType>

    <simpleType name="Use">
        <annotation>
            <documentation>
                <html:p>
                    Describes how an attribute should be used
                </html:p>
            </documentation>
        </annotation>
        <restriction base="xsd:token">
            <enumeration value="optional"/>
            <enumeration value="required"/>
        </restriction>
    </simpleType>

    <simpleType name="Type">
        <annotation>
            <documentation>
                <html:p>
                    Allowed types
                </html:p>
            </documentation>
        </annotation>
        <restriction base="xsd:token">
            <!--
               Allowed String Types
            -->
            <enumeration value="string">
                <annotation>
                    <documentation>
                        <html:p>
                            Any sequence of characters.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="Name">
                <annotation>
                    <documentation>
                        <html:p>
                            A valid name. That is a string that
                            consist exclusively of letters, digits,
                            ideographs, and the underscore, hyphen,
                            period, and colon. Digits, the hyphen, and
                            the period may not be used to start a
                            name, although they may be used inside the
                            name.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="Name*">
                <annotation>
                    <documentation>
                        <html:p>
                            A list of names.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="string*">
                <annotation>
                    <documentation>
                        <html:p>
                            A list of strings.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <!--
              Numeric Types
            -->
            <enumeration value="integer">
                <annotation>
                    <documentation>
                        <html:p>
                            An integer value of arbitrary size.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="long">
                <annotation>
                    <documentation>
                        <html:p>
                            A signed integer that can be represented
                            by eight bytes. The minimum value of a
                            long is 9223372036854775807, the maximum
                            value is -9223372036854775808.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="int">
                <annotation>
                    <documentation>
                        <html:p>
                            A signed integer that can be represented
                            by four bytes. The minimum value of an int
                            is -2147483648, the maximum value is
                            2147483647.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="short">
                <annotation>
                    <documentation>
                        <html:p>
                            A signed integer that can be represented
                            by two bytes. The minimum value of a short
                            is -32768, the maximum value is 32767.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="byte">
                <annotation>
                    <documentation>
                        <html:p>
                            A signed integer that can be represented
                            by a single byte. The minimum value of a byte
                            is -128, the maximum value is 127.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="unsignedLong">
                <annotation>
                    <documentation>
                        <html:p>
                            An unsigned integer that can be
                            represented by eight bytes. The minimum
                            value of a unsignedLong is 0, the maximum
                            value is 18446744073709551615.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="unsignedInt">
                <annotation>
                    <documentation>
                        <html:p>
                            An unsigned integer that can be
                            represented by four bytes. The minimum
                            value of an unsignedInt is 0, the maximum
                            value is 4294967295.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="unsignedShort">
                <annotation>
                    <documentation>
                        <html:p>
                            An unsigned integer that can be
                            represented by two bytes. The minimum
                            value of an unsignedShort is 0, the
                            maximum value is 65535.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="unsignedByte">
                <annotation>
                    <documentation>
                        <html:p>
                            An unsigned integer that can be represented
                            by a single byte. The minimum value of a byte
                            is 0, the maximum value is 255.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="double">
                <annotation>
                    <documentation>
                        <html:p>
                            A decimal value that can be represented by
                            an eight byte floating-point number in
                            IEEE 754 format. Values such as INF
                            (infinity) and NaN (not a number) are
                            allowed.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="float">
                <annotation>
                    <documentation>
                        <html:p>
                            A decimal value that can be represented by
                            a four byte floating-point number in
                            IEEE 754 format. Values such as INF
                            (infinity) and NaN (not a number) are
                            allowed.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="integer*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of integer
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="long*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of long
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="int*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of int
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="short*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of short
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="byte*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of byte
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="unsignedLong*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of unsignedLong
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="unsignedInt*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of unsignedInt
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="unsignedShort*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of unsignedShort
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="unsignedByte*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of unsignedByte
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="double*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of double
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="float*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of float
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>

            <!--
                Booleans
            -->
            <enumeration value="boolean">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of long
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="boolean*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of boolean
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>


            <!--
               ISO 8601 date and time
            -->
            <enumeration value="duration">
                <annotation>
                    <documentation>
                        <html:p>
                            The duration type represents a length
                            of time such as 15 minutes; 2 hours; or 3
                            years, 7 months, 2 days, 8 hours, 32
                            minutes, and 12 seconds. It does not have
                            a specific beginning or end, just a
                            length. Durations are represented using
                            the ISO-8601 standard format
                            PnYnMnDTnHnMnS. nY gives the number of
                            years, nM the number of months, nD the
                            number of days, nH the number of hours, nM
                            the number of minutes, and nS the number
                            of seconds. The number of years, months,
                            days, hours, minutes, and seconds are all
                            given as nonnegative integers. The number
                            of seconds is a decimal number with as
                            many places after the decimal point as
                            necessary. For example, in this format, 3
                            years, 7 months, 2 days, 8 hours, 32
                            minutes, and 12 seconds is written as
                            P3Y7M2DT8H32M12S. Any values that are zero
                            can be omitted. Thus, a duration of 2
                            years and 2 minutes can be written as
                            P2YT2M. If there are no hours, minutes, or
                            seconds, then the T is omitted. Thus, a
                            duration of two years is written as P2Y. A
                            leading minus sign before the P indicates
                            a negative duration.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="date">
                <annotation>
                    <documentation>
                        <html:p>
                          The date type represents a specific day
                          in history such as September 26, 2005. Dates
                          are written in the form CCYY-MM-DD. For
                          example, September 26, 2005 is written as
                          2005-09-26.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="dateTime">
                <annotation>
                    <documentation>
                        <html:p>
                          The dateTime type represents a specific
                          moment in history, such as 3:32 P.M.,
                          September 26, 2003. Date-times are written
                          in the form CCYY-MM-DDThh:mm:ss. An optional
                          time zone indicator in the form hh:mm may
                          be suffixed to provide a time zone as an
                          offset from Coordinated Universal Time
                          (Greenwich Mean Time, UTC). For example,
                          2003-09-26T15:32:00-05:00 is 3:32 P.M.,
                          September 26, 2003 in the U.S. Eastern time
                          zone. A Z can be used instead to indicate
                          UTC: 1999-12-31T00:00:00Z.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="utcDateTime">
                <annotation>
                    <documentation>
                        <html:p>
                            A dateTime constraint to be in the UTC
                            timezone.  That is the timezone offset
                            must be 0 OR the value must end with Z.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="time">
                <annotation>
                    <documentation>
                        <html:p>
                            The time type represents a specific time
                            of day on no particular day, such as 3:32
                            P.M. Times are written in the form
                            hh:mm:ss.xxx using a 24-hour clock and as
                            many fractions of a second as necessary.
                            An optional time zone indicator in the
                            form hh:mm may be suffixed to provide a
                            time zone as an offset from Coordinated
                            Universal Time (Greenwich Mean Time,
                            UTC). For example, 15:32:00-05:00 is 3:32
                            P.M., in the U.S. Eastern time zone. A Z
                            can be used instead to indicate UTC:
                            00:00:00Z.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="utcTime">
                <annotation>
                    <documentation>
                        <html:p>
                            A time constraint to be in the UTC
                            timezone.  That is the timezone offset
                            must be 0 OR the value must end with Z.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="duration*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of duration
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="date*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of date
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="dateTime*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of dateTime
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="utcDateTime*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of utcDateTime
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="time*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of time
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="utcTime*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of utcTime
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="gDay*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of gDay
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="gMonth*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of gMonth
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="gYear*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of gYear
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="gMonthDay*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of gMonthDay
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="gMonthYear*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of gMonthYear
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>

            <!--
                Others
            -->
            <enumeration value="base64Binary">
                <annotation>
                    <documentation>
                        <html:p>
                             An arbitrary sequence of bytes that has
                             been encoded in ASCII characters using
                             the Base-64 algorithm defined in RFC
                             2045, <html:i>Multi-purpose Internet Mail
                             Extensions (MIME) Part One: Format of
                             Internet Message Bodies</html:i>. The
                             letters AZ and az, the digits 09, and
                             the punctuation marks + and / are used to
                             encode data according to an algorithm
                             that maps four of these characters to
                             three arbitrary bytes. The equals sign is
                             used to pad data at the end if necessary.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="anyURI">
                <annotation>
                    <documentation>
                        <html:p>
                          The anyURI type indicates a Uniform Resource
                          Identifier. This includes not only Uniform
                          Resource Locators (URLs), but also Uniform
                          Resource Names (URNs). Both relative and
                          absolute URLs are allowed.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="UUID">
                <annotation>
                    <documentation>
                        <html:p>
                            A Universally unique identifier in its
                            canonical form: 32 hexadecimal digits,
                            displayed in five groups separated by
                            hyphens, in the form 8-4-4-4-12 for a
                            total of 36 characters (32 digits and four
                            hyphens). For example:
                            7eadda6a-9f3e-11e1-9ef4-77b6922f8866.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="anyURI*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of anyURI
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
            <enumeration value="UUID*">
                <annotation>
                    <documentation>
                        <html:p>
                            A whitespace separated list of UUIDs
                            values.
                        </html:p>
                    </documentation>
                </annotation>
            </enumeration>
        </restriction>
    </simpleType>
    <simpleType name="TypeList">
        <list itemType="schema:Type"/>
    </simpleType>
</schema>
